# Helper/Utility Classes

And, since there's always more than one way or even more than two ways of accomplishing something, I'm going to show you one more approach that you can use when writing styles for different `themes` of elements. And that is helper or utility classes.

Going back to our `_grid.scss` file, I'm going to delete this placeholder and move the padding style rule back to the `.grid__widget` class selector. And I'll delete the `@extend` rules in the `magenta` and `green` modifiers as well. Now we're back to having our generic widget styles of the padding in the `grid__widget` selector.

And instead of using the `modifier` selectors for the magenta and green themes, I'm going to replace them with a whole new class selector. So `&--magenta` will become a `&.magenta` class and `&--green` modifier will become a `&.green` class. The reason we still need that ampersand is because the final selector will be `.grid__widget.magenta` with no space between the `grid__widget` and `magenta` classes. This selector will then look for an HTML element that has both classes `grid__widget` and `magenta` in the same element. If we had a space between `grid__widget` and `magenta` it would look for an element that has the class `magenta` that has a parent element of `grid__widget`. So not having the space means both classes are in the same element, and having the space means the classes are in a parent then a child element. And that's a pure CSS feature, not only in Sass.

So in our HTML we'll update our classes. So in the first widget, we still want `grid__widget` as a class to get those generic widget styles. But then we can also add a `magenta` class to this element. And we can do the same for the green widget so that the element has the classes `grid__widget` and `green.` And we'll do the same for the third widget. Now in our website the widgets are all looking the way that they should. If we inspect that first widget, we can see in the Rules that the padding is coming from the `grid__widget` class, and the background-color is coming from the `magenta` class. And the same is true for the green widget.

The `magenta` and `green` classes in this example are what we call `helper` or `utility` classes. This means that the class name has one or just a small number of style rules associated with it that are implied in the class name. One cool thing about utility classes is that they can be reused simply by adding that class name to elements. If we wanted to be able to reuse the magenta and green background colors for elements outside the widgets, we could move them to an entirely new Sass file.

For example, we can take the utility clases from `_grid.scss` and move them into our `globals/_colors.scss` file. And we don't need the ampersand anymore since they're not nested in a parent selector, so it will just be `.magenta` and `.green`.

Now in our website the widgets are taking the correct background color and the background colors are no longer associated with the widget styles but just the `magenta` and `green` class names. What's cooler is that we can now use these utility classes to apply styles simply by editing the HTML, and not having to touch our styles at all. So if we go into our index.html file and switch the magenta and green class names in our widgets, they will change and we didn't need to modify our styles at all.

And we can even use the helper classes in the main element. I'm adding the `magenta` class to the `grid__main` element. However, the main is still blue if we load the website, even though we can see the magenta class name. What's happening is that even though the two style rules are both on style classes, meaning they have the same level of specificity, the utility classes are getting loaded first in our globals, and the `grid__main` styles come later on in the style.css file. This makes the `grid__main` background-color rule override the magenta rule. And we can see that in our inspector, which is why the `magenta` rule is getting crossed out.

So if we did want to be able to control the background color of the main element, I would just remove the blue background-color from the `.grid__main` selector. And perhaps add it as another utility class of `blue` in the `_colors.scss` file. Now when we load our website the main element is magenta. And if we wanted to change it to blue we could simply replace the `magenta` class in `grid__main` with `blue`. And voila, it is changed.

Since utility classes are reusable, they are a nice way to let you modify the styles without needing to keep creating new style rules. This comes in handy especially if your website uses a CMS or content management system like Wordpress. You can customize the website code so that you can set CSS classes on elements directly from the CMS. This is great if you're working on a team or have a client, and want to allow non-developers to make limited changes to the website without having to request a web developer to make the change in code and then having to deploy it.

If you have a whole system of utility classes to control things like flexbox and grid layouts, background colors, and font sizes and styles, it also makes building new pages in an existing website easier because so much of the work to create the new page has been done already, and you can just add the utility classes that you need to the new page. This is exactly what utility-first frameworks like Tailwind are trying to do-- they're essentially a whole web design system and they let you build pages and elements from existing styles that they've created. All you have to do as the user is add the proper classes to the HTML elements.

It is a different approach to building websites-- I know it's not for everyone. And if you're building a website from a completely custom design then you will still have to write all the styles to match that design. I personally like using a combination of mostly BEM with some utility classes. And you'll see more of this as we build out the actual course website later in this course.
