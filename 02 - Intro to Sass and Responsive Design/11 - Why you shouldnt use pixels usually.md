# Why you shouldn't use pixels

Let's start talking about units in CSS. I mentioned a while back that you shouldn't be using the pixel unit for sizing because it's not accessible. So let me show you what this means and why you really shouldn't be using pixels at all, especially not for text sizes.

In our `_typography.scss` file, we have a size for the h1 tag using the clamp() function but we're using pixels and the viewport width unit. Let's add a similar font-size for the h2 tag. I'll copy what we have for h1 and change the selector to h2. And I'm going to tweak the sizes in clamp() to make h2 a bit smaller than h1.

`font-size: clamp(22px, 14px + 1.5vw, 36px)`

And I'll set the paragraph, p tag to `font-size: 16px;`. Now let's go into our browser settings (log out from Firefox first) and change the base font size from the default of 16px to 36, which is more than double the size. This is a feature that allows the user to make the text bigger on all websites if they need. Chrome should have a similar setting. Safari I believe has a setting that says "Never use font sizes smaller than" and then you can choose the minimum size allowed, which ends up being the same thing.

Now when we reload the website, the text hasn't changed at all, even though we increased the base font size to 36px. This is not ideal user experience, because if you change the font size in your settings, you'd expect the text on websites to be larger to match.

The reason it's not changing is because pixels are an absolute unit in CSS. This means that their final size is not dependent on anything else-- the paragraph text will always be 16px no matter what you select in your browser settings. And yes, you can zoom in on the browser to make the text bigger even if the font-size is set in pixels, but because browser settings have that base font size option, I think it's important that we as web developers allow that setting to actually do what it's supposed to. And making your font sizes in an absolute unit like pixels takes away the control that the user should have over the page.

What you want to do is use a relative unit that will scale up if the user increases their base font size in the browser. There are several relative units in CSS, meaning units whose value is dependent on another factor. The viewport width unit is one example of a relative unit, as the value of 1 viewport width is dependent on the width of the device. However, we need a relative unit that is dependent on the base font size in the browser so that it will change when the base font size is changed. And that unit, which is my most often used unit in CSS, is the rem or "root em" unit. There is also an "em" unit which you may have heard of, and I will talk about em units in a little bit.

The "root" in rem is from one rem being equal to the root of the website or the base font size set in the browser. If the default base font size of 16px is set, then 1rem will equal 16px. And if we change our base font size to 36px like we tried before, 1rem will equal 36px. So let's use rem units in all our font sizes and see what happens.

In our `_typography.scss` file, in the h1 element selector, I'm going to duplicate the line using the VS Code shortcut Ctrl-D, then I will comment out the first line with the double slashes. Commenting your code means the line that is commented out will be ignored by the software. So it's a handy way to keep helpful notes or temporarily save some code that you are going to use later.

In the second line I'm going to convert from pixels to rems with the assumption that we'll be using the default 16px as the base font size. So to get from pixels to rems, I'll divide all the pixel values by 16. The 28px will become 1.75rem. Then 16px will be 1rem. And 40px will be 2.5rem.

One thing to note is that the viewport width unit that we're using as our preferred font size in the clamp function is not dependent on base font size, even though it is a relative unit. So 1vw will not change when the base font size changes. But since it's being added to the 1rem, the final calculated value of that middle parameter will still change when the base font size is changed. So that's one thing to keep in mind-- try to only use viewport width units for font-sizing if it's added to a number that is using a unit that is dependent on base font size.

Back to our code. In the h2 element selector, we'll duplicate that line also and comment out the first one. Then 22px divided by 16 will become 1.375rem. 14px will become 0.875rem, and 36px will become 2.25rem. Then in our paragraph selector, the 16px will be 1rem. Now let's load the website and see how this changes things.

In our settings we'll make sure the base font size is set to 16px. And in the browser we'll inspect the h1 tag and check that the updated font-size value is using rems, which does seem to be the case. Let's go back in the settings and change the base font size to 36 again. And when we reload the website everything looks bigger, as if you zoomed in. And you'll notice that the layout is displaying the 1-column mobile layout, not the 2-column desktop one. Again, this is because the breakpoint to change to 2-columns has also scaled up so 43.75em now equals 1575px. This is good user experience, where if you make the base font size bigger, the text size increases, and the breakpoints also adjust. Let's change the base font size back to 16.

So we know now that rem units are much better for accessibility. But what about the "em" unit? Some people like using em units for their font-size, and I think that's ok. But em units have a quirk that can sometimes cause unintended behavior. While rem units are based on the base font size, em units, when used for font-size, are based on the font-size of the parent element. Let me show you what I mean in the code.

I'm going to change the paragraph font-size to 1em. When we inspect the site and check the Computed tab, the 1em results in a 16px font-size, which is what we want. This is because there's no other font-size property in any of the parent elements of the paragraph tag. So the parents would be the main element, then the div with class "grid", body, and html. Now I'm going to go into our `_grid.scss` file and add a font-size to the ".grid" class selector. I'll set it to 2rem, which will equal 16 times 2, 32px.

We'll save, and when we look at the website again, the paragraph text is now really large. This is happening because the 1em in our paragraph styles is basing itself on that 2rem or 32px font-size in the grid class div. So for the paragraph, 1em is equal to whatever the parent font-size is, which in this case is 32px. So 32 times 1 is 32px. And in the Computed tab, it is indeed 32px.

And, this effect is multiplied if multiple ancestor elements use the em unit. Let's change that grid class font-size to 2em units instead of 2rems. Then let's go into our boilerplate styles, and add a font-size to the body tag. Let's say 1.5em.

And now in the website, the paragraph text is really huge. This is happening because of the multiplier effect of the nested elements which are all using em units. The root font size set in our browser is 16px, so the font-size of the body tag is 1.5em, so 16 times 1.5 which is 24. Then the grid class element font size is 2ems which is dependent on its parent the body element. So 1em for the grid class element is 24px, making 2ems 24 times 2 which is 48px. Then the paragraph tag is 1em and it is basing 1em off of the grid class element, so 1em equals 48px, which is what we do see in the computed tab.

Obviously, this is an edge case and it's not going to be something super common. But in my opinion I just find it easier to use rem units because you know it will always be based on the browser's base font size. But it is perfectly fine to use em units-- just make sure that you're aware of that nesting issue if you do. I'm just going to go back and delete those extra font-size changes that I just made. And we'll change this back to 1rem.
